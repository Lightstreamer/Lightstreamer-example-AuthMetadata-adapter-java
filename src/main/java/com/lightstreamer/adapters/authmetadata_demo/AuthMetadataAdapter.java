package com.lightstreamer.adapters.authmetadata_demo;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.lightstreamer.adapters.metadata.LiteralBasedProvider;
import com.lightstreamer.interfaces.metadata.AccessException;
import com.lightstreamer.interfaces.metadata.CreditsException;
import com.lightstreamer.interfaces.metadata.ItemsException;
import com.lightstreamer.interfaces.metadata.NotificationException;
import com.lightstreamer.interfaces.metadata.TableInfo;

public class AuthMetadataAdapter extends LiteralBasedProvider {
    
    private static ExecutorService authProcessingPool = Executors.newCachedThreadPool();

    @Override 
    public CompletableFuture<Void> notifyUser(String user, String token, Map httpHeaders) throws AccessException {
        //A user is logging in, we have to verify if the given token is valid for the given user:
        //the token, if it is a valid one, has been generated by the webserver in response
        //to a user/password login made by the user client, thus we have to ask the same server 
        //(or a common backend like a memcached or a DB) if the received token is (still) valid.
        //This demo does not actually perform the request, user/token pairs are hardcoded in the 
        //AuthorizationRequest class
        
        CompletableFuture<Void> future = new CompletableFuture<>();
        authProcessingPool.execute(() -> {
            try {
                if (!AuthorizationRequest.isValidToken(user, token)) {
                    throw new AccessException("Invalid user/token");
                }
                future.complete(null);
            } catch (Throwable t) {
                future.completeExceptionally(t);
            }
            assert (future.isDone());
        });

        return future;
        
        //NOTE: since we might have to block in order to perform the lookup for the client, we have 
        //configured a dedicated ExecutorService. Moreover, to provide backpressure to the Server
        //when the number of pending operations is too high, we have properly configured the
        //authorization thread pool in the adapters.xml configuration file for this adapter.
        //You might also want to speed up things using a local cache.
        
        //NOTE: it is common practice for a webserver to place its session token inside a cookie;
        //if the cookie,the JS client library, and the Lightstreamer server are properly configured, 
        //such cookie can be available in the httpHeaders Map; you might be tempted to use
        //it to authenticate the user: this approach is discouraged, please check the Server configuration
        //for the <use_protected_js> and <forward_cookies> documentation for further info about the topic. 
    }

    @Override
    public boolean wantsTablesNotification(String user) {
        //We might return false if the user is authorized to subscribe to all the items.
        //In this case we always return true
        return true;
    }
    
    @Override 
    public void notifyNewTables(java.lang.String user, java.lang.String sessionID, TableInfo[] tables) throws NotificationException, CreditsException {
        //A user is subscribing to one or more items, we have to verify if he is authorized to
        //see what he's asking for. This task might be performing by checking an external service
        //or a local cache. If a service has to be queried it is, in most cases, better to query it
        //beforehand in the notifyNewSession method. This class assumes such info has been cached 
        //somewhere else, on the other hand the AuthMetadataAdapterWithAuthCache class (available in 
        //this package) takes a step further and shows the cache-during-notifyNewSession approach.
        //In any case this demo does not actually perform the request, as user authorizations are 
        //hardcoded in the AuthorizationRequest class. 
        
        for (int i=0; i<tables.length; i++) {
            String[] items = tables[i].getSubscribedItems();

            if (!AuthorizationRequest.canUserSeeItems(user, items)) {
                throw new CreditsException(-1, "User not authorized", "You are not authorized to see this item"); 
            }
        }
    }
}
